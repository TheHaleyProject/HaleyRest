using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.IO;
using System.Net.Http;
using System.Runtime;
using System.Runtime.CompilerServices;
using Haley.Models;
using Haley.Enums;
using System.Text.Json;
using System.Xml.Schema;
using Microsoft.Extensions.Logging;
using Haley.Abstractions;
using System.Text.RegularExpressions;
using System.Drawing;

namespace Haley.Utils
{
    public static class NetUtils {
        
        public static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); //In a computing context, an epoch is the date and time relative to which a computer's clock and timestamp values are determined

        public static class OAuth {
            public static string GetNonce(int numberOfBits = 128) {
                //section 3.3 - RFC5849
                
                //A nonce is a random string, uniquely generated by the client to allow the server to verify that a request has never been made before and helps prevent replay attacks when requests are made over a non-secure channel.The nonce value MUST be unique across all requests with the same timestamp, client credentials, and token combinations.

                var _random = RandomUtils.GetString(numberOfBits);
                var _pattern = new Regex("[+/=]");
               return _pattern.Replace(_random, "_");
            }
            public static string GetTimeStamp() {
                //section 3.3 - RFC5849

                //The timestamp value MUST be a positive integer.  Unless otherwise specified by the server's documentation, the timestamp is expressed in the number of seconds since January 1, 1970 00:00:00 GMT.

                return GetUnixTimeStamp(DateTime.UtcNow);
            }
            public static string ConstructRequestUrl(string url) {
                
                return ConstructRequestUrl(uri:new Uri(url));
            }
            public static string ConstructRequestUrl(Uri uri) {
                // Section 3.4.1.2.Base String URI

                //1.The scheme and host MUST be in lowercase.
                //2.The host and port values MUST match the content of the HTTP request "Host" header field.
                //3. The port MUST be included if it is not the default port for the scheme, and MUST be excluded if it is the default.
                if (uri == null) {
                    throw new ArgumentNullException("url");
                }
                var normUrl = string.Format("{0}://{1}", uri.Scheme, uri.Host);
                if (!(uri.Scheme == "http" && uri.Port == 80 ||
                      uri.Scheme == "https" && uri.Port == 443))
                    normUrl += ":" + uri.Port; //add port only if not the default 80 / 443

                normUrl += uri.AbsolutePath; //Path without the query params
                return normUrl;
            }
        }

        public static List<QueryParam> ParseQueryParameters(HttpRequestMessage request, string ignore_prefix = null) {
            string query = String.Empty;
            if (request.RequestUri.IsAbsoluteUri) {
                query = request.RequestUri.Query;
            } else {
                var relative_url = request.RequestUri.ToString();
                int idx = relative_url.IndexOf('?');
                query = idx >= 0 ? relative_url.Substring(idx) : ""; //If there is no question mark, we don't have any parameter for the query
            }
            return ParseQueryParameters(query_string: query, ignore_prefix: ignore_prefix);
        }

        public static async Task<List<QueryParam>> ParseFormEncodedParameters(HttpRequestMessage request, string ignore_prefix = null) {
            if (!request.Headers.TryGetValues("Content-Type", out var values)) return null;
            if (values.First() != "application/x-www-form-urlencoded") return null;
            if (request.Content == null) return null;
            //If the value is form url encoded, then try to get the values and extract them as query parameters.
            var content = await request.Content.ReadAsStringAsync();
            if (string.IsNullOrWhiteSpace(content)) return null;

            return ParseQueryParameters(query_string: content, ignore_prefix: ignore_prefix);
        }

        public static List<QueryParam> ParseQueryParameters(string query_string, string ignore_prefix = null) {
            var result = new List<QueryParam>();

            if (string.IsNullOrWhiteSpace(query_string)) return result;

            var queryString = query_string;
            if (queryString.StartsWith("?"))
                queryString = queryString.Remove(0, 1);

            foreach (var qpair in queryString.Split('&')) {
                if (!string.IsNullOrEmpty(qpair)) {

                    //First ignore the prefixes (if available)
                    if (!string.IsNullOrWhiteSpace(ignore_prefix) && qpair.StartsWith(ignore_prefix)) continue;

                    //because oauth_ protocols are added separately
                    if (qpair.IndexOf('=') > -1) {
                        var temp = qpair.Split('=');

                        var _key = temp[0];
                        var _value = temp[1];

                        result.Add(new QueryParam(_key, _value));
                    } else {
                        var _key = qpair;
                        result.Add(new QueryParam(_key, string.Empty));
                    }
                }
            }
            return result;
        }

        public static string DownloadFromWeb(string download_link, string file_name) {
            try {
                string _path = null;
                _path = Path.Combine(Path.GetTempPath() + file_name);
                if (File.Exists(_path)) File.Delete(_path);
                Uri _download_url = new Uri(download_link);
                using (var _client = new WebClient()) {
                    _client.DownloadFile(_download_url, _path);
                }
                return _path;
            } catch (Exception ex) {
                throw;
            }
        }

        public static string GetUnixTimeStamp(DateTime datetime) {
            //Generate Unix Time (seconds consumed since 1-1-1970)
            var timeSpan = (datetime - Epoch);
            var totalseconds = (long)timeSpan.TotalSeconds;
            return totalseconds.ToString();
        }

        public static string URLSingleEncode(string input,string expectedDecodedValue = null) {
            bool isEncoded = true; //Assuming everything is already encoded.
            var workingValue = input;

            //WHY ExpectedDecodeValue ? => Sometimes, the input itself is meant to have "%23" which is part of the actual string. But when we try to singleencode, we end up decoding that %23 to # which is wrong. So, when we know that there is a expected decoded value, we setit up.

            //It is very important to note that we should not end up with double encoding. So, we first remove any previous encodings and then encode again.
            while (isEncoded) {
                //If we have a stopcheck value, first compare that
                if (expectedDecodedValue != null && workingValue == expectedDecodedValue) {
                    //Stopvalue is to ensure that we might have some kind of encoding (which is already needed and should not be decoded further)
                    isEncoded = false;
                    break; //do not check further.
                }

                isEncoded = (Uri.UnescapeDataString(workingValue) != workingValue); //If unescaped value and working value are same, then it is no longer encoded. we have reached the end.
                if (isEncoded) workingValue = Uri.UnescapeDataString(workingValue);
            }

            //Uri.EscapeDataString is similar to 

            return Uri.EscapeDataString(workingValue); //This gives a proper single Encode over the expected decoded value.
        }
    }
}
