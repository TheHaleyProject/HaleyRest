using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.IO;
using System.Net.Http;
using System.Runtime;
using System.Runtime.CompilerServices;
using Haley.Models;
using Haley.Enums;
using System.Text.Json;
using System.Xml.Schema;
using Microsoft.Extensions.Logging;
using Haley.Abstractions;
using ProtoBuf.WellKnownTypes;
using System.Text.RegularExpressions;
using System.Drawing;

namespace Haley.Utils
{
    public static class NetUtils {
        
        public static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); //In a computing context, an epoch is the date and time relative to which a computer's clock and timestamp values are determined

        public static class OAuth {
            public static string GetNonce(int numberOfBits = 128) {
                //section 3.3 - RFC5849
                
                //A nonce is a random string, uniquely generated by the client to allow the server to verify that a request has never been made before and helps prevent replay attacks when requests are made over a non-secure channel.The nonce value MUST be unique across all requests with the same timestamp, client credentials, and token combinations.

                var _random = HashUtils.GetRandomString(numberOfBits);
                var _pattern = new Regex("[+/=]");
               return _pattern.Replace(_random, "_");
            }
            public static string GetTimeStamp() {
                //section 3.3 - RFC5849

                //The timestamp value MUST be a positive integer.  Unless otherwise specified by the server's documentation, the timestamp is expressed in the number of seconds since January 1, 1970 00:00:00 GMT.

                return GetUnixTimeStamp(DateTime.UtcNow);
            }
            public static string ConstructRequestUrl(string url) {
                
                return ConstructRequestUrl(uri:new Uri(url));
            }
            public static string ConstructRequestUrl(Uri uri) {
                // Section 3.4.1.2.Base String URI

                //1.The scheme and host MUST be in lowercase.
                //2.The host and port values MUST match the content of the HTTP request "Host" header field.
                //3. The port MUST be included if it is not the default port for the scheme, and MUST be excluded if it is the default.
                if (uri == null) {
                    throw new ArgumentNullException("url");
                }
                var normUrl = string.Format("{0}://{1}", uri.Scheme, uri.Host);
                if (!(uri.Scheme == "http" && uri.Port == 80 ||
                      uri.Scheme == "https" && uri.Port == 443))
                    normUrl += ":" + uri.Port;

                normUrl += uri.AbsolutePath;
                return normUrl;
            }

            public static Dictionary<string,string> ParseQueryParameters(HttpRequestMessage request, bool? url_decode = null, string ignore_prefix = "oauth_") {
                string query = String.Empty;
                if (request.RequestUri.IsAbsoluteUri) {
                    query = request.RequestUri.Query;
                } else {
                    var relative_url = request.RequestUri.ToString();
                    int idx = relative_url.IndexOf('?');
                    query = idx >= 0 ? relative_url.Substring(idx) : ""; //If there is no question mark, we don't have any parameter for the query
                }
                return ParseQueryParameters(query_string: query,url_decode:url_decode, ignore_prefix:ignore_prefix);
            }

            public static Dictionary<string, string> ParseQueryParameters(string query_string, bool? url_decode = null,string ignore_prefix = "oauth_") {
                var result = new Dictionary<string, string>();

                if (string.IsNullOrWhiteSpace(query_string)) return result;

                var queryString = query_string;
                if (queryString.StartsWith("?"))
                    queryString = queryString.Remove(0, 1);

                foreach (var qpair in queryString.Split('&')) {
                    if (!string.IsNullOrEmpty(qpair)) {
                        if (!string.IsNullOrWhiteSpace(ignore_prefix) && qpair.StartsWith(ignore_prefix)) continue;

                        //because oauth_ protocols are added separately
                        if (qpair.IndexOf('=') > -1) {
                            var temp = qpair.Split('=');

                            var _key = temp[0];
                            var _value = temp[1];

                            if (url_decode.HasValue && url_decode.Value) {
                                _key = string.IsNullOrWhiteSpace(_key) ? "" : Uri.UnescapeDataString(_key);
                                _value = string.IsNullOrWhiteSpace(_value) ? "" : Uri.UnescapeDataString(_value);
                            }
                            result.Add(_key,_value);
                        }
                        else {
                            var _key = qpair;

                            if (url_decode.HasValue && url_decode.Value) {
                                _key = string.IsNullOrWhiteSpace(_key) ? "" : Uri.UnescapeDataString(_key);
                            }
                            result.Add(_key, string.Empty);
                        }
                    }
                }
                return result;
            }
        }

        internal static readonly string[] UriRfc3986CharsToEscape = { "!", "*", "'", "(", ")" };
        internal static readonly string[] UriRfc3968EscapedHex = { "%21", "%2A", "%27", "%28", "%29" };
        internal const string Digit = "1234567890";
        internal const string Alphabets = "abcdefghijklmnopqrstuvwxyz";
        internal const string AlphabetsUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        internal const string Unreserved = AlphabetsUpper + Alphabets + Digit + "-._~";
        public static string DownloadFromWeb(string download_link, string file_name) {
            try {
                string _path = null;
                _path = Path.Combine(Path.GetTempPath() + file_name);
                if (File.Exists(_path)) File.Delete(_path);
                Uri _download_url = new Uri(download_link);
                using (var _client = new WebClient()) {
                    _client.DownloadFile(_download_url, _path);
                }
                return _path;
            } catch (Exception ex) {
                throw;
            }
        }

        public static string GetUnixTimeStamp(DateTime datetime) {
            //Generate Unix Time (seconds consumed since 1-1-1970)
            var timeSpan = (datetime - Epoch);
            var totalseconds = (long)timeSpan.TotalSeconds;
            return totalseconds.ToString();
        }

        public static string SingleEncode(string input) {
            bool isEncoded = true; //Assuming everything is already encoded.
            var workingValue = input;

            //It is very important to note that we should not end up with double encoding. So, we first remove any previous encodings and then encode again.
            while (isEncoded) {
                isEncoded = Uri.UnescapeDataString(workingValue) != workingValue; //
                if (isEncoded) workingValue = Uri.UnescapeDataString(workingValue);
            }

            return Uri.EscapeDataString(workingValue); //This gives a proper single Encode
        }

        //BELOW PARTS FROM REST SHARP

        #region Rest Sharp(nuget) / OAuth(Nuget) Methods
        public static string UrlEncodeRelaxed(string value) {
            // Escape RFC 3986 chars first.
            var escapedRfc3986 = new StringBuilder(value);

            for (var i = 0; i < UriRfc3986CharsToEscape.Length; i++) {
                var t = UriRfc3986CharsToEscape[i];

                escapedRfc3986.Replace(t, UriRfc3968EscapedHex[i]);
            }

            // Do RFC 2396 escaping by calling the .NET method to do the work.
            var escapedRfc2396 = Uri.EscapeDataString(escapedRfc3986.ToString());

            // Return the fully-RFC3986-escaped string.
            return escapedRfc2396;
        }

        /// <summary>
        /// URL encodes a string based on section 5.1 of the OAuth spec.
        /// Namely, percent encoding with [RFC3986], avoiding unreserved characters,
        /// upper-casing hexadecimal characters, and UTF-8 encoding for text value pairs.
        /// </summary>
        public static string UrlEncodeStrict(string value)
            => string.Join("", value.Select(x => Unreserved.Contains(x) ? x.ToString() : $"%{(byte)x:X2}"));

        public static string ConstructRequestUrl(Uri uri) {
            if (uri == null) {
                throw new ArgumentNullException("url");
            }
            var normUrl = string.Format("{0}://{1}", uri.Scheme, uri.Host);
            if (!(uri.Scheme == "http" && uri.Port == 80 ||
                  uri.Scheme == "https" && uri.Port == 443))
                normUrl += ":" + uri.Port;

            normUrl += uri.AbsolutePath;
            return normUrl;
        }
        #endregion
    }
}
